using NSerialProtocol.Extensions;
using NSerialProtocol.FrameParsers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace NSerialProtocol
{
    public enum FrameErrorType
    {
        BufferOverrun,
        InvalidLength
    }

    public class SerialFrameParser
    {
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// {0} = is the StartFlag
        /// {1} = is the EndFlag
        /// {2} = is the FixedLength
        /// </remarks>
        private readonly string SerialFramePattern = @"{0}((?!{1}).){2}{1}";

        protected RegexOptions RegexOptions { get; } =
            RegexOptions.CultureInvariant | RegexOptions.Multiline;

        /// <summary>
        /// Gets or sets the Regex object for parsing serial packets.
        /// </summary>
        private Regex SerialFrameRegex { get; set; }

        protected int MaxBufferSize { get; set; } = 4096;

        protected string InputBuffer { get; set; } = "";

        private string StartFlag { get; set; } = "";

        private bool HasStartFlag
        {
            get
            {
                return !string.IsNullOrEmpty(StartFlag);
            }
        }

        private string EndFlag { get; set; } = "";

        private int FixedLength { get; set; } = 0;

        private bool IsFixedLength
        {
            get
            {
                return FixedLength > 0;
            }
        }

        private int DynamicLengthIndex { get; set; } = 0;

        private int DynamicLengthByteCount { get; set; } = 0;

        public delegate void SerialFrameReceivedEventHandler(object sender, SerialFrameReceivedEventArgs e);


        public delegate void SerialFrameErrorEventHandler(object sender, SerialFrameErrorEventArgs e);

        /// <summary>
        /// Indicates that a serial frame has been received through a port represented by the
        /// SerialPort object.
        /// </summary>
        public event SerialFrameReceivedEventHandler SerialFrameReceived;

        /// <summary>
        /// Indicates that a framing error has occured.
        /// </summary>
        public event SerialFrameErrorEventHandler SerialFrameError;

        /// <summary>
        /// Replaces all regex meta or special characters with their regex
        /// literal values.
        /// </summary>
        /// <param name="value">String to replace all regex special characters.</param>
        /// <returns>
        /// String with all regex meta characters replaced with their literal
        /// values.
        /// </returns>
        protected string RegexMetaToLiteral(string value)
        {
            string result = string.Empty;

            if (!string.IsNullOrEmpty(value))
            {
                // Regex pattern of regex meta characters to replace
                string regexMetaCharactersPattern = @"(?=[\\^\$\{\}\[\]\(\)\.\*\+\?\|\<\>\&])";

                // Puts a "\" in front of all regex meta characters
                result = Regex.Replace(value, regexMetaCharactersPattern, @"\");
            }

            return result;
        }

        /// <summary>
        /// Instantiates a 
        /// </summary>
        /// <param name="endFlag"></param>
        public SerialFrameParser()
        {
            SerialFrameRegex = new Regex(".*", RegexOptions);
        }

        public SerialFrameParser SetStartFlag(string startFlag)
        {
            StartFlag = startFlag;

            SerialFrameRegex = GetRegex(SerialFramePattern, StartFlag, EndFlag, FixedLength);

            return this;
        }

        public SerialFrameParser SetEndFlag(string endFlag)
        {
            EndFlag = endFlag;

            SerialFrameRegex = GetRegex(SerialFramePattern, StartFlag, EndFlag, FixedLength);

            return this;
        }

        private Regex GetRegex(string pattern, string startFlag, string endFlag, int fixedLength)
        {
            string startFlagLiteral = RegexMetaToLiteral(startFlag);
            string endFlagLiteral = RegexMetaToLiteral(endFlag);
            string fixedLengthLiteral = fixedLength <= 0 ? "*" : fixedLength.ToString();

            pattern = string.Format(pattern, startFlagLiteral, endFlagLiteral, fixedLengthLiteral);

            return new Regex(pattern, RegexOptions);
        }

        public void Parse(string data)
        {
            IList<string> frames = null;
            IList<string> errors = null;

            // Grab data to clear other buffers
            // TODO: Worry about micro-optimization theatre later
            InputBuffer += data;

            if (InputBuffer.Length < MaxBufferSize)
            {
                // Parse frames via regex
                frames = SerialFrameRegex
                    .Matches(InputBuffer)
                    .Cast<Match>()
                    .Select(x => x.Value)
                    .Where(x => x != string.Empty)
                    .ToList();

                // 
                errors = data.Split(frames.ToArray(), StringSplitOptions.RemoveEmptyEntries);
                //errors = errors.Take(errors.Count - 1).ToList();

                // For each good frame...
                for (int i = 0; i < frames.Count(); i++)
                {
                    // Is this a fixed length frame (the frames are ALWAYS the same length?
                    // If it is, is it the proper length?
                    if (IsFixedLength && frames[i].Length != FixedLength)
                    {
                        // Frame is a bad length, send a frame error event
                        SerialFrameError?.Invoke(this, new SerialFrameErrorEventArgs(frames[i], FrameErrorType.InvalidLength));
                    }

                    else
                    {
                        // Frame is good, send frame received event
                        SerialFrameReceived?.Invoke(this, new SerialFrameReceivedEventArgs(frames[i]));
                    }

                    // Clear this frame the InputBuffer to avoid an overrun
                    //InputBuffer = InputBuffer.RemoveThrough(EndFlag, 0, StringComparison.Ordinal);
                    InputBuffer = InputBuffer.RemoveThrough(frames[i]);
                }

                for (int i = 0; i < errors.Count(); i++)
                {
                    if (HasStartFlag && !frames[i].Contains(StartFlag))
                    {

                    }
                }
            }
            else
            {
                // Uhoh, buffer overran its max size
                // Pass entire buffer via frame error event
                SerialFrameError?.Invoke(this, new SerialFrameErrorEventArgs(InputBuffer, FrameErrorType.BufferOverrun));

                // Drop the entire buffer
                InputBuffer = "";
            }
        }

        private List<string> ParseDyanmicLengthFrames(IList<string> frames, int index, int bytes)
        {
            int length = -1;
            byte[] lengthBytes = new byte[bytes];
            byte[] frameBytes;

            for (int i = 0; i < frames.Count; i++)
            {
                frameBytes = Encoding.Default.GetBytes(frames[i]);
                Array.Copy(frameBytes, index, lengthBytes, 0, bytes);

                length = BitConverter.ToInt32(lengthBytes, 0);

                

                //frames.Insert(i, );
                //i++;
            }

            throw new NotImplementedException();
        }

        //private int GetDynamicLength()
        //{

        //}

    }
}
